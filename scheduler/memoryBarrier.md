# 优化内存屏障

# 1.优化的来源
- 在程序执行过程中，指令不按照源程序顺序执行，为了提高软件的性能，会执行两种优化。
1. 编译器优化
- 提升系统性能
- 在不影响逻辑的情况下，调整指令顺序
2. CPU执行优化
- 提升流水线性能
- CPU乱序，导致后面没有寄存器冲突的汇编指令先于前面的指令完成

# 2.优化屏障
- 避免编译重新排序优化操作
- 保证优化屏障之前的指令，不会在优化屏障之后执行
- 内核同步要避免指令的重新排序

- Linux使用宏barrier实现内存屏障
- gcc编译器的优化屏障宏定义为
- 地址: include/linux/compiler-gcc.h
- #define barrier() \_\_asm\_\_ \_\_volatile("":::"memory")
1. \_\_asm\_\_ 插入了汇编语言程序
2. \_\_volatile\_\_ 阻止编译器对该值进行优化 确保变量使用用户定义的精确地址，而不是装有同一信息的一些别名
3. memory 表示修改了内存单元

# 3.内存屏障
内存屏障(内存栅障，屏障指令)，是一类同步屏障指令
CPU或者编译器，对内存访问操作的时候，严格按照一定顺序执行
memory barrier前后的指令，不会由于系统优化等原因导致乱序
1. 编译器屏障
- complier barrier
- 优化屏障之前的指令，不会在优化屏障之后执行
2. CPU屏障(CPU级别内存屏障)
- CPU barrier
- 防止指令之间的重新排序
- 保证数据的可见性

## 3.1CPU内存屏障分类
将硬件内存屏障插入到代码流程中，保证屏障后的操作发生之前，屏障前的操作都处理完成了。
- 插入优化屏障，告知编译器，保存在寄存器中。屏障之前，内存地址有效，屏障之后内存地址消失。
- 编译器在屏障之前发出的读写请求完成之前，不会处理任何之后的读写请求
1. GENERAL (通用内存屏障)
- mb()/smp\_mb()
- 保证读写操作有序
2. WRITE(写屏障)
- wmb()/smp\_wmb()
- 保证写有序
3. READ(读屏障)
- rmb()/smp\_rmb()
- 保证读有序

## 3.2内存屏障作用
解决CPU调整缓存存在的问题
- 无锁技术，内存在线程中共享，没有任何互斥量，才会考虑加入内存屏障
- 编写无锁数据结构，需要内存屏障
- 缓存和主内存的数据，不是实时同步的，CPU缓存和数据也不一致。各个组件，同一时间观察同一数据，都不一致。
