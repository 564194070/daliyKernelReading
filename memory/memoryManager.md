# 内核内存布局

# 1.查看内核内存布局
cat /proc/cpuinfo | grep address 
address size 
- 64位Linux在查询后，会使用48位来表示虚拟地址空间，43位表示物理地址

cpuinfo 参数
- processor 系统中逻辑处理器的核的编号，超线程逻辑核心的编号
- vendor\_id CPU制造商信息
- family CPU序列的代号
- model CPU序列下某代产品
- model name CPU全称
- stepping CPU制作更新的版本
- fpu 浮点运算单元
- wp 当前CPU是否支持内核态对用户空间的写保护

# 2.查看内存使用状况
cat /proc/meminfo

meminfo参数
- memTotal 安装物理总容量数目
- memFree 当前未使用空闲内存量
- 

# 3.ARM64架构处理器寻址机制
采用48位物理寻址机制，虚拟地址同样也支持48位寻址。
- 最大可寻找256TB物理地址空间，虚拟地址寻址同样支持48位寻址
- 处理器架构上将内存划分为两个空间，用户空间和内核空间，都占用256TB
1. 用户空间 0x0000\_0000\_0000\_0000 到 0x0000\_ffff\_ffff\_ffff
2. 内核空间 0xffff\_0000\_0000\-0000 到 0xffff\_ffff\_ffff\_ffff
3. 虚拟地址和每个进程的页表映射，获取到真正的物理地址。不在物理地址中，就产生缺页中断，真正分配物理地址，更新进程页表。
4. 物理内存被耗尽，会根据内存替换算法，淘汰页面到物理磁盘
5. arm64 一般使用64KB页面，二级转换表，支持42位虚拟地址，4TB
6. 4KB页面会使用3级或者4级转换表，支持39位，512GB，支持48位，256TB虚拟地址。

# 3.1 用户空间和内核空间
1. 内核空间
- 线性映射区
- .data 数据段 内核初始化的全局变量
- .init 大部分模块的初始化数据，初始化结束，就是释放对应的内存
- .text 代码段 \_text代码段起始地址 \_etext代码段结束地址
- modules 128MB内核模块区域，内核模块使用的虚拟地址空间
- PCI I/O PCI设备I/O地址空间
- vmemmap 内存物理地址(不连续就会存在内存空洞),用于存放空洞内存的page结构的虚拟地址空间
- vmalloc 使用虚拟地址空间
- 非规范区域


2. 用户空间

